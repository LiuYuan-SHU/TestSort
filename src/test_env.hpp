//
// Created by Liu Yuan on 2023/9/22.
//

#ifndef SORT_SRC_TEST_ENV_HPP_
#define SORT_SRC_TEST_ENV_HPP_

#include <gtest/gtest.h>

#include <array>
#include <random>
#include <vector>

/**
 * @brief The sorting algorithm information, provided in main.cpp by user.
 * The data is provided by `testing::TestWithParam<algorithm_info>`, and 
 * then access by `GetParam()`.
 */
struct algorithm_info {
  /**
   * @brief The sorting algorithm
   */
  std::function<void(std::vector<int> &)> algorithm;
  /**
   * @brief The name of the sorting algorithm
   */
  std::string name;
};

/**
 * @brief The test environment
 */
class test_env : public testing::TestWithParam<algorithm_info> {
protected:
  /**
   * @brief Test cases, generated by generate_data()
   */
  static std::vector<std::vector<int>> test_cases;

  /**
   * @brief In order to save time, the capacity of the test_cases should
   * be initialized at the very beginning. This flag shows if the test_cases
   * are initialized.
   */
  static bool is_init;
  /**
   * @brief Random device 
   */
  static std::random_device rd;
  /**
   * @brief Random generator
   */
  static std::mt19937 gen;

protected:
  static void init_vecs();
  /**
   * @brief The number of numbers in the vec, 
   * the size of the test data vec will be :
   * 1, 2, 4, ..., 2 ^ `TEST_CASE_NUM`
   */
  static constexpr size_t TEST_CASE_NUM = 10;
  /**
   * @brief The generated numbers will be in the range of
   * [-TEST_CASE_NUM_RANGE, TEST_CASE_NUM_RANGE], for more
   * detailed info, please check the comments in `rand_type`
   */
  static constexpr int TEST_CASE_NUM_RANGE = 1000;

protected:
  /**
   * @brief The sorting algorithm of this round, the next
   * algorithm will not be tested until this algorithm is
   * finished.
   */
  std::function<void(std::vector<int> &)> sort_algorithm;
  /**
   * @brief The name of the testing algorithm
   */
  std::string algorithm_name;

public:
  explicit inline test_env() {
    const algorithm_info &info = GetParam();
    sort_algorithm = info.algorithm;
    algorithm_name = info.name;
  }

public:
  /**
   * @brief The generated test data type
   * 
   */
  enum rand_type {
    empty,    // empty vec
    uniform,  // uniform: U(-TEST_CASE_NUM_RANGE)
    normal,   // normal: N(0, TEST_CASE_NUM_RANGE)
    poisson,  // possion: P(TEST_CASE_NUM_RANGE)
    ordered,  // ordered: [INT_FAST32_MIN, INT_FAST32_MAX]
    inverted, // inverted [INT_FAST32_MIN, INT_FAST32_MAX]
    rand_type_count
  };

private:
  /**
   * @brief generate empty test data
   */
  static void generate_empty();
  /**
   * @brief generate uniform distribution test data
   */
  static void generate_uniform();
  /**
   * @brief generate normal distribution test data
   */
  static void generate_normal();
  /**
   * @brief generate Possion distribution test data
   */
  static void generate_poisson();
  /**
   * @brief generate ordered test data
   */
  static void generate_ordered();
  /**
   * @brief generate inverted test data
   */
  static void generate_inverted();

protected:
  /**
   * @brief Measure the time cost of the sorting algorithm
   * 
   * @param arr The test data
   * @param judge The judge function, if the sorting algorithm is correct,
   * the judge function should return true, otherwise false.
   * @param error_info The error information provided by user, will be 
   * printed if the judge function returns false.
   */
  void measure_and_print(std::vector<int> &arr, std::function<bool()> judge,
                         const std::string &error_info);

public:
  static void generate_data(rand_type type);

public:
  inline void SetUp() override { init_vecs(); }
};

#endif // SORT_SRC_TEST_ENV_HPP_
